<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"/> <meta content="width=device-width, initial-scale=1.0" name="viewport"/> <title>Reverse-Engineering - Got Detected</title> <meta content="Reverse-Engineering Home / Concepts / Reverse-Engineering..." name="description"/> <meta content="reverse-engineering" name="keywords"/> <meta content="index, follow" name="robots"/> <link href="../assets/style.css" rel="stylesheet"/> <!-- Prism.js for syntax highlighting --> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/> <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script> <!-- Fuse.js for search --> <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script> </head> <body> <nav class="site-nav"> <a class="brand" href="../index.html">Got Detected</a> <div class="nav-links"> <a href="../index.html">Home</a> <a href="../overview.html">Overview</a> <a href="../concepts/index.html">Concepts</a> <a href="../guides/index.html">Guides</a> <a href="../glossary.html">Glossary</a> </div> <div class="search-container"> <input class="search-input" id="search-input" placeholder="Search..." type="text"/> <div class="search-results" id="search-results"></div> </div> </nav> <main class="content-wrapper"> <h1>Reverse-Engineering</h1> <nav class="breadcrumb"> <a href="../index.html">Home</a> / <a href="index.html">Concepts</a> / Reverse-Engineering </nav> <div class="content-wrapper"> <article class="concept"> <div class="toc"><h3>On This Page</h3><ul class="toc-list"><li class="toc-section"><a href="#definition-of-the-concept">Definition of the concept</a> </li> <li class="toc-section"><a href="#key-insights">Key Insights</a> </li> <li class="toc-section"><a href="#why-it-matters-relevance-and-importance">Why It Matters: Relevance and importance</a> </li> <li class="toc-section"><a href="#common-challenges-problems-it-addresses">Common Challenges: Problems it addresses</a> </li> <li class="toc-section"><a href="#solutions-and-approaches-actionable-solutions">Solutions and Approaches: Actionable solutions</a> </li> <li class="toc-section"><a href="#real-world-patterns-examples-and-patterns">Real-World Patterns: Examples and patterns</a> </li> <li class="toc-section"><a href="#advanced-considerations-for-experienced-users">Advanced Considerations: For experienced users</a> </li> <li class="toc-section"><a href="#why-it-matters">Why It Matters</a> <ul class="toc-subsections"> <li class="toc-subsection"><a href="#common-challenges">Common Challenges</a></li> <li class="toc-subsection"><a href="#solutions-and-approaches">Solutions and Approaches</a></li> <li class="toc-subsection"><a href="#real-world-patterns">Real-World Patterns</a></li> <li class="toc-subsection"><a href="#advanced-considerations">Advanced Considerations</a></li> </ul> </li> <li class="toc-section"><a href="#obfuscation-techniques">Obfuscation Techniques</a> </li> <li class="toc-section"><a href="#anti-reverse-engineering-measures">Anti-Reverse Engineering Measures</a> </li> <li class="toc-section"><a href="#virtualization-and-emulation">Virtualization and Emulation</a> </li> <li class="toc-section"><a href="#captcha-solvers">Captcha Solvers</a> </li> <li class="toc-section"><a href="#proxies-and-browsers">Proxies and Browsers</a> </li> <li class="toc-section"><a href="#reverse-analysis-tools">Reverse Analysis Tools</a> </li> <li class="toc-section"><a href="#conclusion">Conclusion</a> <ul class="toc-subsections"> <li class="toc-subsection"><a href="#common-challenges-in-reverse-engineering">Common Challenges in Reverse-Engineering</a></li> <li class="toc-subsection"><a href="#solutions-and-approaches">Solutions and Approaches</a></li> <li class="toc-subsection"><a href="#real-world-patterns">Real-World Patterns</a></li> <li class="toc-subsection"><a href="#advanced-considerations">Advanced Considerations</a></li> </ul> </li> <li class="toc-section"><a href="#common-challenges-in-reverse-engineering-for-web-s">Common Challenges in Reverse-Engineering for Web Scraping</a> </li> <li class="toc-section"><a href="#real-world-examples-of-reverse-engineering-for-web">Real-World Examples of Reverse-Engineering for Web Scraping</a> <ul class="toc-subsections"> <li class="toc-subsection"><a href="#example-1-using-proxies-to-bypass-anti-scraping-me">Example 1: Using Proxies to Bypass Anti-Scraping Measures</a></li> <li class="toc-subsection"><a href="#example-2-using-javascript-libraries-to-solve-capt">Example 2: Using JavaScript Libraries to Solve CAPTCHAs</a></li> <li class="toc-subsection"><a href="#example-3-using-webassembly-to-virtualize-websites">Example 3: Using WebAssembly to Virtualize Websites</a></li> <li class="toc-subsection"><a href="#understanding-the-complexity-of-reverse-engineerin">Understanding the Complexity of Reverse-Engineering</a></li> <li class="toc-subsection"><a href="#common-challenges-in-reverse-engineering">Common Challenges in Reverse-Engineering</a></li> </ul> </li></ul></div> <h1>What is Reverse-Engineering?</h1> <p>Reverse-engineering (RE) is the process of analyzing and understanding how a system, product, or software works by examining its internal structure, behavior, and interactions. It involves identifying the components, mechanisms, and relationships that enable the system to function as intended.</p> <h2 id="definition-of-the-concept">Definition of the concept</h2> <p>Reverse-engineering can be applied to various fields, including computer science, engineering, and cybersecurity. In the context of web scraping, reverse-engineering is used to analyze and understand how a website's functionality works, identify vulnerabilities, and develop more effective scraping tools.</p> <h2 id="key-insights">Key Insights</h2> <p><strong>Understanding Reverse-Engineering: A Key to Unlocking Complex Systems</strong></p> <p>Reverse-engineering is a crucial skill for web scraping professionals, allowing them to analyze and understand how systems work by dissecting their internal structure and behavior. Think of it like taking apart a complex machine to see how its individual components fit together. In the context of web scraping, reverse-engineering helps identify vulnerabilities, develop more efficient tools, and improve website functionality.</p> <p><strong>Practical Insights: Deconstructing Complex Algorithms</strong></p> <p>When it comes to reverse-engineering, one common challenge is understanding complex algorithms and data structures used in web applications. To overcome this, consider using a combination of manual analysis and automated tools like JavaScript decompilers or disassemblers. For instance, you can use the <code>esprima</code> library to parse JavaScript code and identify patterns, or utilize the <code>node-disassembler</code> tool to analyze native code. By combining these approaches, you can gain a deeper understanding of how algorithms work and develop more effective scraping tools.</p> <p><strong>Important Considerations: Staying Ahead of the Curve</strong></p> <p>As web technologies evolve rapidly, it's essential to stay up-to-date with the latest trends and developments. This includes keeping an eye on emerging programming languages, frameworks, and libraries that can impact your reverse-engineering efforts. For example, JavaScript's growing use in enterprise environments means understanding how modern web applications are built and maintained is crucial for effective scraping. Additionally, consider the security implications of your tools and techniques – a well-designed reverse-engineered solution should prioritize user privacy and website integrity. By staying informed and adaptable, you can maintain a competitive edge in the field of web scraping.</p> <h2 id="why-it-matters-relevance-and-importance">Why It Matters: Relevance and importance</h2> <p>Reverse-engineering is crucial in web scraping as it allows developers to:</p> <ul> <li>Identify and exploit vulnerabilities in websites</li> <li>Develop more efficient and effective scraping tools</li> <li>Understand the inner workings of complex systems</li> <li>Improve website functionality and user experience</li> </ul> <h2 id="common-challenges-problems-it-addresses">Common Challenges: Problems it addresses</h2> <p>Common challenges faced by reverse-engineers include:</p> <ul> <li>Identifying and bypassing security measures, such as CAPTCHAs and rate limiting</li> <li>Understanding complex algorithms and data structures used in web applications</li> <li>Developing tools that can efficiently scrape large amounts of data from websites</li> <li>Staying up-to-date with the latest web technologies and trends</li> </ul> <h2 id="solutions-and-approaches-actionable-solutions">Solutions and Approaches: Actionable solutions</h2> <p>To overcome these challenges, reverse-engineers use various approaches, including:</p> <ul> <li>Analyzing website source code to identify vulnerabilities and patterns</li> <li>Using debugging tools and software development kits (SDKs) to understand system behavior</li> <li>Developing custom scraping tools and scripts to automate data extraction</li> <li>Collaborating with other developers and researchers to share knowledge and best practices</li> </ul> <h2 id="real-world-patterns-examples-and-patterns">Real-World Patterns: Examples and patterns</h2> <p>Real-world examples of reverse-engineering in web scraping include:</p> <ul> <li>Analyzing the source code of popular web scraping libraries, such as Scrapy or Octoparse</li> <li>Identifying vulnerabilities in websites using tools like Burp Suite or ZAP</li> <li>Developing custom scraping tools to extract data from complex systems, such as e-commerce platforms or social media sites</li> </ul> <h2 id="advanced-considerations-for-experienced-users">Advanced Considerations: For experienced users</h2> <p>For experienced reverse-engineers, advanced considerations include:</p> <ul> <li>Understanding the latest web technologies and trends, such as WebAssembly or PWA</li> <li>Developing custom machine learning models to improve scraping efficiency</li> <li>Collaborating with other researchers to develop new techniques for identifying vulnerabilities</li> <li>Staying up-to-date with the latest security measures and countermeasures</li> </ul> <h2 id="why-it-matters">Why It Matters</h2> <p>Reverse-engineering is crucial for web scraping professionals as it enables them to analyze and understand how systems, products, or software work by examining their internal structure, behavior, and interactions. This process helps identify vulnerabilities, security weaknesses, and potential attack vectors.</p> <h3 id="common-challenges">Common Challenges</h3> <ul> <li><strong>Security</strong>: Reverse-engineering can help identify security vulnerabilities in websites, applications, or systems.</li> <li><strong>Performance Optimization</strong>: Analyzing the performance of web scraping tools and techniques is essential for improving efficiency and reducing latency.</li> <li><strong>Compliance</strong>: Understanding how reverse-engineered code behaves under different scenarios is critical for ensuring compliance with regulations and industry standards.</li> </ul> <h3 id="solutions-and-approaches">Solutions and Approaches</h3> <ol> <li><strong>Use of Reverse Engineering Tools</strong>: Utilize specialized tools designed for reverse engineering, such as debuggers or disassemblers, to analyze the behavior of web scraping tools.</li> <li><strong>Code Review</strong>: Conduct thorough code reviews to identify potential security vulnerabilities or performance bottlenecks in web scraping scripts.</li> <li><strong>Testing and Validation</strong>: Perform extensive testing and validation to ensure that web scraping tools function correctly under various scenarios.</li> </ol> <h3 id="real-world-patterns">Real-World Patterns</h3> <ol> <li><strong>Obfuscation Techniques</strong>: Reverse-engineering can help identify obfuscation techniques used by developers to protect their code, such as encryption or anti-debugging measures.</li> <li><strong>Virtualization</strong>: Analyzing virtualized environments and the impact of reverse engineering on them is crucial for ensuring the security and performance of web scraping tools.</li> </ol> <h3 id="advanced-considerations">Advanced Considerations</h3> <ol> <li><strong>Advanced Reverse Engineering Techniques</strong>: Familiarize yourself with advanced reverse engineering techniques, such as binary analysis or network protocol analysis.</li> <li><strong>Integration with Other Tools</strong>: Learn how to integrate reverse-engineered code with other tools and systems, ensuring seamless functionality and performance.</li> </ol> <p>By understanding the importance of reverse-engineering in web scraping, professionals can develop a deeper appreciation for the complexities involved and improve their skills in analyzing and optimizing web scraping tools and techniques.</p> <h1>Common Challenges in Reverse-Engineering</h1> <p>Reverse-engineering is a complex process that involves analyzing and understanding how a system, product, or software works by examining its internal structure, behavior, and interactions. The following are some common challenges faced while reverse-engineering:</p> <h2 id="obfuscation-techniques">Obfuscation Techniques</h2> <p>Obfuscation techniques are used to make the code difficult to understand and analyze. Some common obfuscation techniques include:</p> <ul> <li><strong>Code Obfuscation</strong>: This involves modifying the source code of a program in such a way that it is difficult for humans to understand.</li> <li><strong>Data Obfuscation</strong>: This involves hiding data in a way that makes it difficult to extract or analyze.</li> </ul> <h2 id="anti-reverse-engineering-measures">Anti-Reverse Engineering Measures</h2> <p>Some systems and software use anti-reverse engineering measures to prevent reverse-engineering. These measures include:</p> <ul> <li><strong>Encryption</strong>: This involves encrypting the code or data to make it unreadable.</li> <li><strong>Compression</strong>: This involves compressing the code or data to make it difficult to analyze.</li> </ul> <h2 id="virtualization-and-emulation">Virtualization and Emulation</h2> <p>Virtualization and emulation are used to create a virtual environment that mimics the behavior of a real system. This can be useful for reverse-engineering, but it also presents challenges:</p> <ul> <li><strong>Performance Overhead</strong>: Virtualization and emulation can introduce performance overhead, which can make it difficult to analyze the code or data.</li> <li><strong>Inaccurate Results</strong>: The virtual environment may not accurately represent the behavior of the real system, leading to inaccurate results.</li> </ul> <h2 id="captcha-solvers">Captcha Solvers</h2> <p>Captcha solvers are used to solve captchas and gain access to restricted areas. However, they also present challenges:</p> <ul> <li><strong>Security Risks</strong>: Captcha solvers can pose security risks if they are not used properly.</li> <li><strong>Performance Overhead</strong>: Solving captchas can introduce performance overhead, which can make it difficult to analyze the code or data.</li> </ul> <h2 id="proxies-and-browsers">Proxies and Browsers</h2> <p>Proxies and browsers are used to access restricted areas and analyze web content. However, they also present challenges:</p> <ul> <li><strong>Performance Overhead</strong>: Using proxies and browsers can introduce performance overhead, which can make it difficult to analyze the code or data.</li> <li><strong>Inaccurate Results</strong>: The proxy or browser may not accurately represent the behavior of the real system, leading to inaccurate results.</li> </ul> <h2 id="reverse-analysis-tools">Reverse Analysis Tools</h2> <p>Reverse analysis tools are used to analyze and understand how a system, product, or software works. However, they also present challenges:</p> <ul> <li><strong>Performance Overhead</strong>: Using reverse analysis tools can introduce performance overhead, which can make it difficult to analyze the code or data.</li> <li><strong>Inaccurate Results</strong>: The tool may not accurately represent the behavior of the real system, leading to inaccurate results.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>Reverse-engineering is a complex process that involves analyzing and understanding how a system, product, or software works. However, it also presents challenges such as obfuscation techniques, anti-reverse engineering measures, virtualization and emulation, captcha solvers, proxies and browsers, and reverse analysis tools. By understanding these challenges, developers can better navigate the complexities of reverse-engineering and create more secure systems.</p> <p>Solutions and Approaches</p> <p>========================</p> <p>Reverse-engineering is a crucial skill for web scraping professionals, as it allows them to analyze and understand how a system or software works by examining its internal structure, behavior, and interactions.</p> <h3 id="common-challenges-in-reverse-engineering">Common Challenges in Reverse-Engineering</h3> <ol> <li><strong>Obfuscation</strong>: Many systems use obfuscation techniques to make their code difficult to reverse-engineer.</li> <li><strong>Encryption</strong>: Some systems encrypt their data or communication, making it harder to analyze.</li> <li><strong>Virtualization</strong>: Virtualized environments can make it challenging to identify the underlying system.</li> </ol> <h3 id="solutions-and-approaches">Solutions and Approaches</h3> <h4 id="1-deobfuscation-techniques">1. Deobfuscation Techniques</h4> <ul> <li>Use static analysis tools like <code>deobfusmate</code> or <code>reverse-tiny</code> to deobfuscate code.</li> <li>Employ dynamic analysis techniques, such as debugging or fuzz testing, to understand how the system behaves.</li> <li>Utilize machine learning algorithms to identify patterns in the system's behavior.</li> </ul> <h4 id="2-encryption-and-decryption">2. Encryption and Decryption</h4> <ul> <li>Use cryptographic tools like OpenSSL or GnuPG to decrypt encrypted data.</li> <li>Implement encryption-decryption protocols, such as SSL/TLS, to secure communication.</li> </ul> <h4 id="3-virtualization-and-emulation">3. Virtualization and Emulation</h4> <ul> <li>Utilize virtualization platforms like VMware or VirtualBox to create a virtual environment.</li> <li>Employ emulation techniques, such as QEMU or Docker, to simulate the system's behavior.</li> </ul> <h3 id="real-world-patterns">Real-World Patterns</h3> <ol> <li><strong>WebAssembly</strong>: Use WebAssembly to optimize performance and security in web scraping applications.</li> <li><strong>JS Pro</strong>: Utilize JS Pro to deobfuscate JavaScript-heavy websites.</li> </ol> <h3 id="advanced-considerations">Advanced Considerations</h3> <ul> <li><strong>Reverse Analysis Methods</strong>: Study various reverse analysis methods, such as static and dynamic analysis, to improve your skills.</li> <li><strong>Virtualization Protection</strong>: Understand how virtualization protection works and learn techniques to bypass it.</li> </ul> <h1>Real-World Patterns</h1> <p>Reverse-engineering is often applied to various fields, including computer science and cybersecurity. In the context of web scraping, reverse-engineering can be used to analyze and understand how a system or software works by examining its internal structure, behavior, and interactions.</p> <h2 id="common-challenges-in-reverse-engineering-for-web-s">Common Challenges in Reverse-Engineering for Web Scraping</h2> <p>One common challenge in reverse-engineering for web scraping is dealing with anti-scraping measures such as CAPTCHAs. CAPTCHAs are designed to prevent automated scripts from accessing a website's content. However, some tools and techniques can help bypass these measures.</p> <h2 id="real-world-examples-of-reverse-engineering-for-web">Real-World Examples of Reverse-Engineering for Web Scraping</h2> <h3 id="example-1-using-proxies-to-bypass-anti-scraping-me">Example 1: Using Proxies to Bypass Anti-Scraping Measures</h3> <p>Proxies can be used to bypass anti-scraping measures such as CAPTCHAs. By using a proxy server, you can mask your IP address and make it appear as though the request is coming from a different location.</p> <pre><code class="language-javascript">const axios = require('axios'); // Set up proxy server const proxy = 'http://proxy.example.com:8080'; // Make request to website axios.get('https://example.com', { proxy }).then(response =&gt; { console.log(response.data); }).catch(error =&gt; { console.error(error); });</code></pre> <h3 id="example-2-using-javascript-libraries-to-solve-capt">Example 2: Using JavaScript Libraries to Solve CAPTCHAs</h3> <p>Some JavaScript libraries can be used to solve CAPTCHAs. For example, the Google reCAPTCHA library provides a way to verify that a user is human.</p> <pre><code class="language-javascript">const recaptcha = require('google-recaptcha'); # // Set up reCAPTCHA library recaptcha.setApiKey('YOUR_API_KEY'); recaptcha.setSiteKey('YOUR_SITE_KEY'); // Verify reCAPTCHA response axios.post('https://example.com/verify', { 'response': recaptcha.verify() }).then(response =&gt; { console.log(response.data); }).catch(error =&gt; { console.error(error); });</code></pre> <h3 id="example-3-using-webassembly-to-virtualize-websites">Example 3: Using WebAssembly to Virtualize Websites</h3> <p>WebAssembly can be used to virtualize websites and make it easier to scrape their content. By compiling a website's JavaScript code into WebAssembly, you can run the code in a sandboxed environment.</p> <pre><code class="language-javascript">const wasm = require('wasm'); // Compile website's JavaScript code into WebAssembly const compiledCode = wasm.compile('https://example.com/script.js'); // Run compiled code in sandboxed environment const result = compiledCode.run(); console.log(result);</code></pre> <p>These are just a few examples of how reverse-engineering can be used to solve common challenges in web scraping. By understanding how websites work and using the right tools and techniques, you can build more effective scrapers.</p> <h1>Advanced Considerations for Reverse-Engineering</h1> <h3 id="understanding-the-complexity-of-reverse-engineerin">Understanding the Complexity of Reverse-Engineering</h3> <p>Reverse-engineering is a complex process that requires a deep understanding of the system, product, or software being analyzed. It involves identifying the components, mechanisms, and relationships that enable the system to function as intended.</p> <h3 id="common-challenges-in-reverse-engineering">Common Challenges in Reverse-Engineering</h3> <ol> <li><strong>Obfuscation</strong>: Many modern systems use obfuscation techniques to make it difficult for reverse-engineers to understand their internal workings.</li> <li><strong>Encryption</strong>: Encryption can make it challenging to analyze the data being transmitted or stored by a system.</li> <li><strong>Virtualization</strong>: Virtualization technologies can create complex virtual environments that are difficult to reverse-engineer.</li> </ol> <h3 id="solutions-and-approaches">Solutions and Approaches</h3> <ol> <li><strong>Static Analysis</strong>: Static analysis involves examining the source code of a system without executing it. This can provide valuable insights into the internal workings of a system.</li> <li><strong>Dynamic Analysis</strong>: Dynamic analysis involves executing a system and analyzing its behavior in real-time. This can help identify vulnerabilities or weaknesses in a system's design.</li> <li><strong>Fuzz Testing</strong>: Fuzz testing involves sending random input to a system to test its robustness and identify potential vulnerabilities.</li> </ol> <h3 id="real-world-patterns">Real-World Patterns</h3> <ol> <li><strong>Use of Obfuscation Techniques</strong>: Many modern systems use obfuscation techniques such as encryption, compression, or code obfuscation to make it difficult for reverse-engineers to understand their internal workings.</li> <li><strong>Virtualization Technologies</strong>: Virtualization technologies such as VMware or VirtualBox can create complex virtual environments that are difficult to reverse-engineer.</li> </ol> <h3 id="advanced-considerations">Advanced Considerations</h3> <ol> <li><strong>Understanding the System's Architecture</strong>: Understanding the system's architecture is crucial in reverse-engineering a system. This involves identifying the components, mechanisms, and relationships that enable the system to function as intended.</li> <li><strong>Identifying Obfuscation Techniques</strong>: Identifying obfuscation techniques such as encryption or compression can help reverse-engineers understand the internal workings of a system.</li> <li><strong>Using Advanced Tools and Techniques</strong>: Using advanced tools and techniques such as fuzz testing or static analysis can help identify vulnerabilities or weaknesses in a system's design.</li> </ol> <h3 id="example-analyzing-an-obfuscated-system">Example: Analyzing an Obfuscated System</h3> <p>Suppose we have a system that is obfuscated using encryption and compression. To analyze this system, we can use the following steps:</p> <ol> <li><strong>Decompress the Data</strong>: Decompressing the data can provide valuable insights into the internal workings of the system.</li> <li><strong>Decrypt the Data</strong>: Decrypting the data can help identify the source code or other sensitive information that is being protected by obfuscation techniques.</li> <li><strong>Use Advanced Tools and Techniques</strong>: Using advanced tools and techniques such as fuzz testing or static analysis can help identify vulnerabilities or weaknesses in a system's design.</li> </ol> <p>By following these steps, we can gain valuable insights into the internal workings of an obfuscated system and identify potential vulnerabilities or weaknesses in its design.</p> <h2 id="examples">Examples</h2> </article> <aside class="sidebar"> <h3>External Resources</h3><ul><ul> <li><strong>Repositories:</strong> <ul> <li><a href="https://github.com/cisco/joy" rel="noopener" target="_blank">joy</a></li> </ul> </li> <li><strong>External Resources:</strong> <ul> <li><a href="https://jscrambler.com/" rel="noopener" target="_blank">jscrambler.com</a></li> <li><a href="http://www.dsi.unive.it/~avp/collberg97taxonomy.pdf" rel="noopener" target="_blank">www.dsi.unive.it</a></li> <li><a href="http://www.javascriptobfuscator.com/" rel="noopener" target="_blank">www.javascriptobfuscator.com</a></li> <li><a href="https://arxiv.org/abs/1706.08003" rel="noopener" target="_blank">arxiv.org</a></li> </ul> </li> </ul></ul> </aside> </div> <section class="related-content"> <h2>Related Content</h2> <ul class="related-content-list"><li><a href="web-scraping-with-deep-learning.html">Web Scraping with Deep Learning</a></li><li><a href="web-scraping-with-machine-learning.html">Web Scraping with Machine Learning</a></li><li><a href="tools-and-software.html">Tools and Software</a></li><li><a href="web-crawling.html">Web Crawling</a></li><li><a href="web-scraping-basics.html">Web Scraping Basics</a></li></ul> </section> </main> <footer><p>Created with ❤️ by <a href="https://github.com/StackedQueries/document-ai" target="_blank">Document AI</a></p></footer> <script src="../assets/search.js"></script> <script src="../assets/copy-code.js"></script> </body> </html>